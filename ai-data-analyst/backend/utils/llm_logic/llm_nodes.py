from backend.utils.llm_logic.utils.executor import execute_python_code_restricted
from llm_chains import code_chain, response_chain, action_selection_chain
from backend.utils.llm_logic.utils.parsers import CodeBlockParser
from .state import DFState
import json

'''
            +----------------+
            |   User Input   |
            +----------------+
                   |
                   v
        +------------------------+
        | 1. Action Selector     |  
        +------------------------+
            ^             ^
            |             |
            v             v
+----------------+   +------------------+
| Response Node  |   | Code Generator   |
+----------------+   +------------------+
            |
            v
    +----------------+
    |  User Output   |
    +----------------+

'''


def action_selection_node(state: DFState) -> DFState:
    # Selects the action to be performed based on the user input and state
    action_output = action_selection_chain.invoke({"state": state}).content
    try:
        # Parse the JSON response and update state
        action_state = json.loads(action_output)
        state["action_state"] = action_state
        return state
    except Exception as e:
        state["error"] = f"Action selection failed: {str(e)}"
        return state

def code_node(state: DFState) -> DFState:
    # Executes the code generated by the LLM
    if state["action_state"]["action"] != "generate_code":
        return state
    
    code_parser = CodeBlockParser()
    output = code_chain.invoke({"state": state}).content
    code = code_parser.parse(output)
    
    try:
        df, code_output = execute_python_code_restricted(state["df"], code)
        state["df"] = df
        state["code_output"] = code_output
        state["latest_tool_output"] = code_output
        state["error"] = None
    except Exception as e:
        state["error"] = str(e)
        state["latest_tool_output"] = f"[ERROR] {str(e)}"
        state["code_output"] = None
        state["latest_tool_output"] = None
    
    return state

def response_node(state: DFState) -> DFState:
    #Generates a response to return to the user
    if state["action_state"]["action"] != "response":
        return state
        
    response_output = response_chain.invoke({"state": state}).content
    state["latest_tool_output"] = response_output
    state["chat_history"].append(("assistant", response_output))
    
    return state